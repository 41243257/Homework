# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CO2E-Ihg65EHh2qIW8DPsyFcgVHvG_ci
"""

import numpy as np
import matplotlib.pyplot as plt

# ── 題目參數 ──────────────────────────────────────────
ts = 80e-3          # seek time  (80 ms)   — 此範例未細算，保留變數
t1 = 20e-3          # 旋轉延遲 (20 ms)      — 此範例未細算，保留變數
n  = 200_000        # 總紀錄數
m  = 64             # 可用緩衝頁面數 ⇒ k ≤ m-1
tr = 1e-3           # 傳輸時間 (1 ms / record)
S  = 2_000          # 初始 run 數

# ── k 範圍：2…63（m-1）───────────────────────────────
k_vals = np.arange(2, m)       # 2 〜 64（含 63）

# ── 需要的 merge pass：ceil(log_k S) ─────────────────
passes = np.ceil(np.log(S) / np.log(k_vals))

# ── 每個 pass 的 I/O 時間（讀 + 寫 n 筆）────────────────
t_per_pass = 2 * n * tr        # = 400 s；如要含 ts+t1，可自行加入

# ── 總 t_input(k) ─────────────────────────────────────
t_input = passes * t_per_pass   # 單位：秒

# ── 假設 CPU 合併時間為常數 ──────────────────────────
t_CPU = 800                    # 題目指定「常數時間」，此處示例 800 s

# ── 繪圖 ─────────────────────────────────────────────
plt.figure(figsize=(10, 5))

# 階梯圖：I/O 時間
plt.step(k_vals, t_input, where='post', label='t_input(k)')

# 水平虛線：CPU 時間
plt.axhline(
    y=t_CPU,
    color='red',
    alpha=0.7,
    linestyle='--',
    linewidth=2,
    label='t_CPU = 800 s'
)

# 標註 k ≥ 45 時重疊（只需 2 pass）
plt.annotate(
    't_input = t_CPU (k ≥ 45)',
    xy=(45, t_CPU),
    xytext=(30, t_CPU + 150),
    arrowprops=dict(arrowstyle='->')
)

plt.xlabel('k (k-way merge fan-in)')
plt.ylabel('Total Input Time t_input (seconds)')
plt.title('t_input vs. k  (n = 200,000, S = 2000)')
plt.xticks(k_vals[::5])  # 每隔 5 個 k 標一次刻度
plt.grid(True, linestyle=':')
plt.legend()
plt.tight_layout()
plt.show()